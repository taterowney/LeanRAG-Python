{
  "train": {
    "Mathlib": [
      "Mathlib/Geometry/Euclidean/Sphere/Ptolemy.lean",
      "Mathlib/NumberTheory/Transcendental/Liouville/Basic.lean",
      "Mathlib/Algebra/Order/Group/Cone.lean",
      "Mathlib/Geometry/Manifold/IntegralCurve/Basic.lean",
      "Mathlib/RingTheory/Bialgebra/TensorProduct.lean",
      "Mathlib/RingTheory/Spectrum/Prime/Polynomial.lean",
      "Mathlib/RingTheory/IntegralClosure/Algebra/Basic.lean",
      "Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean",
      "Mathlib/Analysis/NormedSpace/ConformalLinearMap.lean",
      "Mathlib/Algebra/Homology/HomologicalComplexBiprod.lean",
      "Mathlib/CategoryTheory/Abelian/Projective/Resolution.lean",
      "Mathlib/CategoryTheory/Localization/Triangulated.lean",
      "Mathlib/Algebra/Algebra/Subalgebra/Unitization.lean",
      "Mathlib/Analysis/Normed/Affine/ContinuousAffineMap.lean",
      "Mathlib/Algebra/EuclideanDomain/Defs.lean",
      "Mathlib/Algebra/Ring/Subring/Units.lean"
    ]
  },
  "test": {
    "FLT": [
      {
        "file": "FLT/Mathlib/Topology/Algebra/UniformRing.lean",
        "theorems": [
          "UniformSpace.Completion.mapRingHom_apply"
        ]
      },
      {
        "file": "FLT/Mathlib/LinearAlgebra/Determinant.lean",
        "theorems": [
          "LinearMap.det_mul"
        ]
      },
      {
        "file": "FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean",
        "theorems": [
          "IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap"
        ]
      },
      {
        "file": "FLT/Mathlib/Algebra/Algebra/Hom.lean",
        "theorems": [
          "SemialgHom.map_smul"
        ]
      },
      {
        "file": "FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean",
        "theorems": [
          "PadicInt.closure_nonZeroDivisors_padicInt"
        ]
      },
      {
        "file": "FLT/HaarMeasure/DistribHaarChar/Padic.lean",
        "theorems": [
          "distribHaarChar_padic_padicInt"
        ]
      },
      {
        "file": "FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean",
        "theorems": [
          "PadicInt.nnnorm_units"
        ]
      },
      {
        "file": "FLT/Mathlib/Topology/Algebra/UniformRing.lean",
        "theorems": [
          "UniformSpace.Completion.mapRingHom_coe"
        ]
      },
      {
        "file": "FLT/Mathlib/LinearAlgebra/Span/Defs.lean",
        "theorems": [
          "Submodule.coe_sup'"
        ]
      },
      {
        "file": "FLT/Mathlib/Analysis/Normed/Ring/WithAbs.lean",
        "theorems": [
          "WithAbs.uniformContinuous_algebraMap"
        ]
      },
      {
        "file": "FLT/HaarMeasure/DistribHaarChar/Padic.lean",
        "theorems": [
          "distribHaarChar_padicInt"
        ]
      },
      {
        "file": "FLT/HaarMeasure/MeasurableSpacePadics.lean",
        "theorems": [
          "PadicInt.volume_univ"
        ]
      },
      {
        "file": "FLT/HaarMeasure/DistribHaarChar/RealComplex.lean",
        "theorems": [
          "distribHaarChar_real"
        ]
      },
      {
        "file": "FLT/HaarMeasure/DistribHaarChar/Basic.lean",
        "theorems": [
          "MeasureTheory.Measure.distribHaarChar_pos"
        ]
      },
      {
        "file": "FLT/Mathlib/MeasureTheory/Group/Action.lean",
        "theorems": [
          "MeasureTheory.index_mul_haar_subgroup_eq_haar_subgroup"
        ]
      },
      {
        "file": "FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean",
        "theorems": [
          "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom_tmul_apply"
        ]
      },
      {
        "file": "FLT/Mathlib/Analysis/Normed/Ring/WithAbs.lean",
        "theorems": [
          "WithAbs.norm_eq_abs"
        ]
      },
      {
        "file": "FLT/Mathlib/Algebra/Algebra/Pi.lean",
        "theorems": [
          "Pi.semialgHom_apply"
        ]
      },
      {
        "file": "FLT/Mathlib/GroupTheory/Index.lean",
        "theorems": [
          "AddSubgroup.index_smul"
        ]
      },
      {
        "file": "FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean",
        "theorems": [
          "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom_coe"
        ]
      },
      {
        "file": "FLT/HaarMeasure/DistribHaarChar/RealComplex.lean",
        "theorems": [
          "Complex.volume_complex_smul"
        ]
      },
      {
        "file": "FLT/HaarMeasure/DistribHaarChar/Basic.lean",
        "theorems": [
          "MeasureTheory.Measure.distribHaarChar_eq_of_measure_smul_eq_mul"
        ]
      },
      {
        "file": "FLT/Mathlib/Algebra/Algebra/Hom.lean",
        "theorems": [
          "SemialgHom.commutes"
        ]
      },
      {
        "file": "FLT/HaarMeasure/DistribHaarChar/RealComplex.lean",
        "theorems": [
          "distribHaarChar_complex"
        ]
      },
      {
        "file": "FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean",
        "theorems": [
          "IsDedekindDomain.HeightOneSpectrum.range_adicCompletionComapAlgIso_tensorAdicCompletionIntegersTo_le_pi"
        ]
      },
      {
        "file": "FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean",
        "theorems": [
          "PadicInt.image_coe_smul_set"
        ]
      },
      {
        "file": "FLT/Mathlib/Topology/Constructions.lean",
        "theorems": [
          "DenseRange.piMap"
        ]
      },
      {
        "file": "FLT/Deformations/RepresentationTheory/Subrepresentation.lean",
        "theorems": [
          "Subrepresentation.toSubmodule_inf"
        ]
      },
      {
        "file": "FLT/HaarMeasure/MeasurableSpacePadics.lean",
        "theorems": [
          "PadicInt.isMeasurableEmbedding_coe"
        ]
      },
      {
        "file": "FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean",
        "theorems": [
          "PadicInt.nnnorm_p"
        ]
      },
      {
        "file": "FLT/Mathlib/Algebra/Algebra/Hom.lean",
        "theorems": [
          "SemialgHom.toLinearMap_eq_coe"
        ]
      },
      {
        "file": "FLT/HaarMeasure/DomMulActMeasure.lean",
        "theorems": [
          "MeasureTheory.Measure.domSMul_apply"
        ]
      },
      {
        "file": "FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean",
        "theorems": [
          "PadicInt.nnnorm_pow"
        ]
      },
      {
        "file": "FLT/HaarMeasure/DistribHaarChar/Padic.lean",
        "theorems": [
          "Padic.volume_padic_smul"
        ]
      }
    ],
    "foundation": [
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_all₁"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/K4_K45.lean",
        "theorems": [
          "LO.Modal.Hilbert.K4_weakerThan_K45"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_cast"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/GL_Independency.lean",
        "theorems": [
          "LO.Modal.Hilbert.GL.unprovable_not_higherIndependency_of_consistency"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/KB_KDB.lean",
        "theorems": [
          "LO.Modal.Hilbert.KB_strictlyWeakerThan_KDB"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/KB5_S5.lean",
        "theorems": [
          "LO.Modal.Hilbert.KB5_strictlyWeakerThan_S5"
        ]
      },
      {
        "file": "Foundation/Vorspiel/Vorspiel.lean",
        "theorems": [
          "List.Vector.get_one"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_ex₁"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_mdp"
        ]
      },
      {
        "file": "Foundation/Modal/IntProp.lean",
        "theorems": [
          "LO.IntProp.Formula.toModalFormula.def_or"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_and₃"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/K5_KD5.lean",
        "theorems": [
          "LO.Modal.Hilbert.K5_strictlyWeakerThan_KD5"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/KD_KDB.lean",
        "theorems": [
          "LO.Modal.Hilbert.KD_weakerThan_KDB"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/KB5_S5.lean",
        "theorems": [
          "LO.Modal.Hilbert.KB5_weakerThan_S5"
        ]
      },
      {
        "file": "Foundation/Logic/Predicate/Rew.lean",
        "theorems": [
          "LO.FirstOrder.Rew.substs_bv"
        ]
      },
      {
        "file": "Foundation/IntProp/Heyting/Semantics.lean",
        "theorems": [
          "LO.IntProp.Formula.hVal_neg"
        ]
      },
      {
        "file": "Foundation/Modal/Kripke/Geach/Basic.lean",
        "theorems": [
          "LO.Modal.Kripke.TransitiveEuclideanFrameClass.is_geach"
        ]
      },
      {
        "file": "Foundation/Modal/NNFormula.lean",
        "theorems": [
          "LO.Modal.Formula.toNNFormula_atom"
        ]
      },
      {
        "file": "Foundation/FirstOrder/Hauptsatz.lean",
        "theorems": [
          "LO.FirstOrder.Derivation.isCutFree_wk_iff"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/KB_KDB.lean",
        "theorems": [
          "LO.Modal.Hilbert.KB_weakerThan_KDB"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/K4_KD4.lean",
        "theorems": [
          "LO.Modal.Hilbert.K4_weakerThan_KD4"
        ]
      },
      {
        "file": "Foundation/FirstOrder/Hauptsatz.lean",
        "theorems": [
          "LO.FirstOrder.Derivation.isCutFree_all_iff"
        ]
      },
      {
        "file": "Foundation/Logic/Predicate/Rew.lean",
        "theorems": [
          "LO.FirstOrder.LawfulSyntacticRewriting.rewrite_substs_nil"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_gen"
        ]
      },
      {
        "file": "Foundation/FirstOrder/Hauptsatz.lean",
        "theorems": [
          "LO.FirstOrder.PositiveDerivationFrom.graft_isCutFree_of_isCutFree"
        ]
      },
      {
        "file": "Foundation/Modal/NNFormula.lean",
        "theorems": [
          "LO.Modal.NNFormula.toFormula_natom"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_imply₂"
        ]
      },
      {
        "file": "Foundation/Modal/IntProp.lean",
        "theorems": [
          "LO.IntProp.Formula.toModalFormula.def_and"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/KD5_KD45.lean",
        "theorems": [
          "LO.Modal.Hilbert.KD5_weakerThan_KD45"
        ]
      },
      {
        "file": "Foundation/FirstOrder/Hauptsatz.lean",
        "theorems": [
          "LO.FirstOrder.Derivation.isCutFree_ex_iff"
        ]
      },
      {
        "file": "Foundation/Modal/Kripke/Geach/Basic.lean",
        "theorems": [
          "LO.Modal.Kripke.SerialTransitiveFrameClass.is_geach"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_rewrite"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_verum"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/K45_KB4.lean",
        "theorems": [
          "LO.Modal.Hilbert.K45_strictlyWeakerThan_KB4"
        ]
      },
      {
        "file": "Foundation/Modal/Kripke/Geach/Basic.lean",
        "theorems": [
          "LO.Modal.Kripke.SerialEuclideanFrameClass.is_geach"
        ]
      },
      {
        "file": "Foundation/Modal/IntProp.lean",
        "theorems": [
          "LO.IntProp.Formula.toModalFormula.def_top"
        ]
      },
      {
        "file": "Foundation/Modal/Kripke/Grz/Definability.lean",
        "theorems": [
          "LO.Modal.Kripke.ReflexiveTransitiveAntiSymmetricFiniteFrameClass.is_defined_by_Grz"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/K4_K45.lean",
        "theorems": [
          "LO.Modal.Hilbert.K4_strictlyWeakerThan_K45"
        ]
      },
      {
        "file": "Foundation/Modal/Kripke/NNFormula.lean",
        "theorems": [
          "LO.Modal.NNFormula.Kripke.Satisfies.natom_def"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/GL_Independency.lean",
        "theorems": [
          "LO.Modal.Hilbert.GL.unprovable_independency"
        ]
      },
      {
        "file": "Foundation/IntFO/Translation.lean",
        "theorems": [
          "LO.FirstOrder.Sequent.neg_neg_eq"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_or₁"
        ]
      },
      {
        "file": "Foundation/IntFO/Translation.lean",
        "theorems": [
          "LO.FirstOrder.Semiformula.substitute_doubleNegation"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/K45_KB4.lean",
        "theorems": [
          "LO.Modal.Hilbert.K45_weakerThan_KB4"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/WeakerThan/KD5_KD45.lean",
        "theorems": [
          "LO.Modal.Hilbert.KD5_strictlyWeakerThan_KD45"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_ex₂"
        ]
      },
      {
        "file": "Foundation/IntFO/Basic/Deduction.lean",
        "theorems": [
          "LO.FirstOrder.HilbertProofᵢ.depth_all₂"
        ]
      },
      {
        "file": "Foundation/FirstOrder/Hauptsatz.lean",
        "theorems": [
          "LO.FirstOrder.Derivation.isCutFree_and_iff"
        ]
      },
      {
        "file": "Foundation/Logic/HilbertStyle/Supplemental.lean",
        "theorems": [
          "LO.System.dne_or!"
        ]
      },
      {
        "file": "Foundation/Modal/Hilbert/GL_Independency.lean",
        "theorems": [
          "LO.Modal.Hilbert.GL.unprovable_notbox"
        ]
      }
    ],
    "HepLean": [
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/Basic.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.ι_commute_fieldOpFreeAlgebra_superCommuteF_ofCrAnOpF_ofCrAnOpF"
        ]
      },
      {
        "file": "HepLean/Lorentz/SL2C/SelfAdjoint.lean",
        "theorems": [
          "Lorentz.SL2C.toSelfAdjointMap_mul"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/Sign/Join.lean",
        "theorems": [
          "WickContraction.join_singleton_sign_right"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldStatistics/Basic.lean",
        "theorems": [
          "FieldStatistic.ofList_freeMonoid"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/UncontractedList.lean",
        "theorems": [
          "WickContraction.fin_list_sorted_indexOf_mem"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpFreeAlgebra/TimeOrder.lean",
        "theorems": [
          "FieldSpecification.FieldOpFreeAlgebra.timeOrderF_timeOrderF_left"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/InsertAndContract.lean",
        "theorems": [
          "WickContraction.insertAndContract_isSome_getDual?_self"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Basic.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.ι_normalOrderF_zero_of_mem_ideal"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.normalOrder_ofFieldOpList_mul_anPart_swap"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpFreeAlgebra/Grading.lean",
        "theorems": [
          "FieldSpecification.FieldOpFreeAlgebra.bosonicProjF_of_fermionic_part"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.superCommute_ofCrAnList_ofFieldOpList"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean",
        "theorems": [
          "FieldSpecification.FieldOpFreeAlgebra.mulLinearMap_apply"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/Grading.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.fermionicProjFree_zero_of_ι_zero"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.normalOrder_superCommute_eq_zero"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/SubContraction.lean",
        "theorems": [
          "WickContraction.quotContraction_fstFieldOfContract_uncontractedListEmd"
        ]
      },
      {
        "file": "HepLean/Mathematics/List/InsertIdx.lean",
        "theorems": [
          "HepLean.List.get_eq_insertIdx_succAbove"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/Join.lean",
        "theorems": [
          "WickContraction.join_fstFieldOfContract_joinLiftLeft"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Basic.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.ι_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero_mul"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.ι_timeOrderF_superCommuteF_neq_time"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/ExtractEquiv.lean",
        "theorems": [
          "WickContraction.extractEquiv_equiv"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.ι_timeOrderF_zero_of_mem_ideal"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/Sign/Join.lean",
        "theorems": [
          "WickContraction.join_singleton_signFinset_eq_filter"
        ]
      },
      {
        "file": "HepLean/Mathematics/Fin/Involutions.lean",
        "theorems": [
          "HepLean.Fin.involutionAddEquiv_cast"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/Koszul/KoszulSign.lean",
        "theorems": [
          "Wick.koszulSign_perm_eq_append"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.ofFieldOp_mul_ofFieldOp_eq_superCommute"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldSpecification/Filters.lean",
        "theorems": [
          "FieldSpecification.annihilateFilter_cons_create"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean",
        "theorems": [
          "FieldSpecification.FieldOpFreeAlgebra.superCommuteF_ofCrAnListF_ofCrAnListF"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpFreeAlgebra/NormTimeOrder.lean",
        "theorems": [
          "FieldSpecification.FieldOpFreeAlgebra.normTimeOrder_ofCrAnListF"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.superCommute_ofCrAnList_ofFieldOpList_eq_sum"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/TimeCond.lean",
        "theorems": [
          "WickContraction.eqTimeContractSet_of_not_haveEqTime"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.timeOrder_ofFieldOpList_singleton"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/Grading.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.fermionicProj_mem_bosonic"
        ]
      },
      {
        "file": "HepLean/Mathematics/Fin/Involutions.lean",
        "theorems": [
          "HepLean.Fin.involutionNoFixed_card_succ"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/Sign/InsertNone.lean",
        "theorems": [
          "WickContraction.signInsertNone_eq_filter_map"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpFreeAlgebra/NormalOrder.lean",
        "theorems": [
          "FieldSpecification.FieldOpFreeAlgebra.normalOrderF_superCommuteF_annihilate_create"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/Basic.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.fermionicProjF_mem_ideal"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/Basic.lean",
        "theorems": [
          "WickContraction.sndFieldOfContract_mem"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/Singleton.lean",
        "theorems": [
          "WickContraction.of_singleton_eq"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.normalOrder_normalOrder_left"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean",
        "theorems": [
          "FieldSpecification.FieldOpFreeAlgebra.summerCommute_jacobi_ofCrAnListF"
        ]
      },
      {
        "file": "HepLean/Mathematics/Fin/Involutions.lean",
        "theorems": [
          "HepLean.Fin.involutionNoFixed_card_odd"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/SubContraction.lean",
        "theorems": [
          "WickContraction.mem_subContraction_or_quotContraction"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/UncontractedList.lean",
        "theorems": [
          "WickContraction.uncontractedList_getElem_uncontractedIndexEquiv_symm"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpAlgebra/Grading.lean",
        "theorems": [
          "FieldSpecification.FieldOpAlgebra.bosonicProj_bosonicProj_eq_bosonicProj"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/Koszul/KoszulSign.lean",
        "theorems": [
          "Wick.koszulSign_singleton"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/InsertAndContractNat.lean",
        "theorems": [
          "WickContraction.insertLift_injective"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/CreateAnnihilate.lean",
        "theorems": [
          "CreateAnnihilate.sum_eq"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean",
        "theorems": [
          "FieldSpecification.FieldOpFreeAlgebra.anPartF_mul_crPartF_eq_superCommuteF"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/FieldStatistics/Basic.lean",
        "theorems": [
          "FieldStatistic.ofList_append"
        ]
      },
      {
        "file": "HepLean/PerturbationTheory/WickContraction/UncontractedList.lean",
        "theorems": [
          "WickContraction.uncontractedListEmd_mem_uncontracted"
        ]
      }
    ],
    "Seymour": [
      {
        "file": "Seymour/ForMathlib/SetTheory.lean",
        "theorems": [
          "singleton_inter_subset_right"
        ]
      },
      {
        "file": "Seymour/ForMathlib/SetTheory.lean",
        "theorems": [
          "ssubset_disjoint_nonempty_union"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/SumDelta/CircuitForms.lean",
        "theorems": [
          "DeltaSumCircuitForm3.singleton_subset_inter"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/CircuitAxioms.lean",
        "theorems": [
          "CircuitPredicate.C3_strong_circuit_elim"
        ]
      },
      {
        "file": "Seymour/Matroid/Constructors/VectorMatroid.lean",
        "theorems": [
          "VectorMatroid.dual_exists_standardRepr"
        ]
      },
      {
        "file": "Seymour/ForMathlib/SetTheory.lean",
        "theorems": [
          "disjoint_of_singleton_inter_subset_left"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumCircuitType2.disjoint_inter"
        ]
      },
      {
        "file": "Seymour/Matroid/Constructors/VectorMatroid.lean",
        "theorems": [
          "StandardRepr.toVectorMatroid_A"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumAssumptions.build2sumCircuitMatroid_circuitPred"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumCircuitType1.disjoint_inter"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/Circuit.lean",
        "theorems": [
          "Matroid.Circuit.indep_diff_singleton"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/Circuit.lean",
        "theorems": [
          "Matroid.Circuit.not_ssubset_circuit"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/DisjointCircuitFamily.lean",
        "theorems": [
          "Matroid.IsUnionDisjointCircuits.dep_or_empty"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/CircuitAxioms.lean",
        "theorems": [
          "ValidFamily.mem_of_elem"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/Loop.lean",
        "theorems": [
          "Matroid.loop_iff_circuit"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/MatrixSums/BinaryMatroids.lean",
        "theorems": [
          "Matrix.indepCols_subset"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/IndepAxioms.lean",
        "theorems": [
          "Matroid.indepEmpty"
        ]
      },
      {
        "file": "Seymour/ForMathlib/SetTheory.lean",
        "theorems": [
          "sub_union_diff_sub_union"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/SumDelta/CircuitForms.lean",
        "theorems": [
          "DeltaSumCircuitForm3.disjoint_inter_M₁_M₂"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumCircuitType2.subset_M₂_diff_inter"
        ]
      },
      {
        "file": "Seymour/ForMathlib/SetTheory.lean",
        "theorems": [
          "disjoint_of_singleton_inter_left_wo"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/Connectivity.lean",
        "theorems": [
          "Matroid.singleton_separator_iff"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/IndepAxioms.lean",
        "theorems": [
          "Matroid.indepAug'"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/CircuitAxioms.lean",
        "theorems": [
          "CircuitPredicate.toIndepPredicate_indepEmpty"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumAssumptions.twoSumCircuitPred_notCircuitEmpty"
        ]
      },
      {
        "file": "Seymour/Basic.lean",
        "theorems": [
          "toUnion_toSum"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumCircuitType2.circuit_M₂"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/Circuit.lean",
        "theorems": [
          "Matroid.Circuit.nonempty"
        ]
      },
      {
        "file": "Seymour/ForMathlib/MatrixTU.lean",
        "theorems": [
          "Matrix.IsTotallyUnimodular.comp_cols"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/MatrixSums/Sum3.lean",
        "theorems": [
          "StandardRepresentation.Is3sumOf.interXX"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/SumDelta/CircuitForms.lean",
        "theorems": [
          "DeltaSumCircuitForm3.disjoint_inter_M₁_inter_M₂"
        ]
      },
      {
        "file": "Seymour/ForMathlib/SetTheory.lean",
        "theorems": [
          "set_union_union_eq_rev"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/SumDelta/CircuitForms.lean",
        "theorems": [
          "DeltaSumCircuitForm3.singleton_subset_M₁"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/Circuit.lean",
        "theorems": [
          "Matroid.ext_iff_circuit"
        ]
      },
      {
        "file": "Seymour/ForMathlib/SetTheory.lean",
        "theorems": [
          "diff_inter_disjoint_diff_inter"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumAssumptions.circuitType2_not_ssubset"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/Coloop.lean",
        "theorems": [
          "Matroid.coloop_iff_in_no_circuit"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Regularity.lean",
        "theorems": [
          "TwoSumAssumptions.decomposition_isRegular_both"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumAssumptions.inter_singleton_not_coloop_M₁"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/Circuit.lean",
        "theorems": [
          "Matroid.Circuit.ssubset_not_circuit"
        ]
      },
      {
        "file": "Seymour/Matroid/Classes/Graphic.lean",
        "theorems": [
          "Matroid.IsGraphic.isRegular"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/SumDelta/Basic.lean",
        "theorems": [
          "DeltaSumCircuitsAux.eq_symmDiff"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/MatrixSums/Sum3.lean",
        "theorems": [
          "StandardRepresentation.Is3sumOf.interYY"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumCircuitType2.subset_union"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumCircuitType3.disjoint_inter_M₂_inter"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/DisjointCircuitFamily.lean",
        "theorems": [
          "Matroid.emptyUnionDisjointCircuits"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum2/Basic.lean",
        "theorems": [
          "TwoSumAssumptions.inter_singleton"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/Sum1/Regularity.lean",
        "theorems": [
          "Disjoint.decomposition_isRegular_both"
        ]
      },
      {
        "file": "Seymour/Matroid/Operations/SumDelta/Basic.lean",
        "theorems": [
          "DeltaSumCircuitsAux.udc_right"
        ]
      },
      {
        "file": "Seymour/Matroid/Notions/CircuitAxioms.lean",
        "theorems": [
          "CircuitPredicate.strong_circuit_elim_weak_circuit_elim"
        ]
      }
    ],
    "carleson": [
      {
        "file": "Carleson/Discrete/ForestUnion.lean",
        "theorems": [
          "C6_forest'"
        ]
      },
      {
        "file": "Carleson/Defs.lean",
        "theorems": [
          "le_upperRadius"
        ]
      },
      {
        "file": "Carleson/Classical/HilbertStrongType.lean",
        "theorems": [
          "mean_zero_oscillation"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.co_subset_oo"
        ]
      },
      {
        "file": "Carleson/ForestOperator/PointwiseEstimate.lean",
        "theorems": [
          "TileStructure.Forest.L7_1_4_integrand_bound"
        ]
      },
      {
        "file": "Carleson/ForestOperator/PointwiseEstimate.lean",
        "theorems": [
          "TileStructure.Forest.approxOnCube_apply"
        ]
      },
      {
        "file": "Carleson/Discrete/ForestUnion.lean",
        "theorems": [
          "C5_1_2_optimized_le'"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.co_union_ci"
        ]
      },
      {
        "file": "Carleson/ForestOperator/PointwiseEstimate.lean",
        "theorems": [
          "TileStructure.Forest.subset_of_mem_𝓛"
        ]
      },
      {
        "file": "Carleson/ToMathlib/WeakType.lean",
        "theorems": [
          "MeasureTheory.toReal_ofReal_preimage'"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Misc.lean",
        "theorems": [
          "MeasureTheory.setIntegral_biUnion_le_sum_setIntegral"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.oo_eq_empty"
        ]
      },
      {
        "file": "Carleson/ForestOperator/PointwiseEstimate.lean",
        "theorems": [
          "TileStructure.Forest.exp_sub_one_le"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.Annulus.co_subset_co"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.oc_union_oo"
        ]
      },
      {
        "file": "Carleson/ToMathlib/RealInterpolation.lean",
        "theorems": [
          "MeasureTheory.AESubadditiveOn.zero"
        ]
      },
      {
        "file": "Carleson/ToMathlib/BoundedCompactSupport.lean",
        "theorems": [
          "MeasureTheory.BoundedCompactSupport.isBoundedSupport'"
        ]
      },
      {
        "file": "Carleson/Psi.lean",
        "theorems": [
          "ennnorm_K_le"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.oc_subset_co"
        ]
      },
      {
        "file": "Carleson/ForestOperator/PointwiseEstimate.lean",
        "theorems": [
          "TileStructure.Forest.L7_1_6_integral_le"
        ]
      },
      {
        "file": "Carleson/ToMathlib/HardyLittlewood.lean",
        "theorems": [
          "MB_ae_ne_top"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.Annulus.cc_subset_oo"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.measurableSet_co"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.Annulus.oo_eq"
        ]
      },
      {
        "file": "Carleson/ToMathlib/BoundedCompactSupport.lean",
        "theorems": [
          "MeasureTheory.isBounded_range_iff_forall_norm_le"
        ]
      },
      {
        "file": "Carleson/ToMathlib/WeakType.lean",
        "theorems": [
          "MeasureTheory.distribution_toReal_eq"
        ]
      },
      {
        "file": "Carleson/ForestOperator/PointwiseEstimate.lean",
        "theorems": [
          "TileStructure.Forest.exists_p_of_mem_σ"
        ]
      },
      {
        "file": "Carleson/Discrete/ForestComplement.lean",
        "theorems": [
          "lintegral_carlesonSum_𝔓₁_compl_le_sum_aux1"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.Annulus.oc_eq"
        ]
      },
      {
        "file": "Carleson/ToMathlib/WeakType.lean",
        "theorems": [
          "MeasureTheory.HasWeakType.memWℒp"
        ]
      },
      {
        "file": "Carleson/Defs.lean",
        "theorems": [
          "inv_q_sub_half_nonneg"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.measurableSet_ci"
        ]
      },
      {
        "file": "Carleson/Psi.lean",
        "theorems": [
          "support_ψS_subset_Icc"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.ci_eq_annulus"
        ]
      },
      {
        "file": "Carleson/Discrete/ForestComplement.lean",
        "theorems": [
          "carlesonSum_𝔓pos_inter_ℭ₁_eq_add_sum"
        ]
      },
      {
        "file": "Carleson/ToMathlib/RealInterpolation.lean",
        "theorems": [
          "MeasureTheory.AESublinearOn.biSup2"
        ]
      },
      {
        "file": "Carleson/Defs.lean",
        "theorems": [
          "volume_G_lt_top"
        ]
      },
      {
        "file": "Carleson/ForestOperator/PointwiseEstimate.lean",
        "theorems": [
          "TileStructure.Forest.ball_covered_by_𝓙"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.co_subset_oc"
        ]
      },
      {
        "file": "Carleson/ForestOperator/L2Estimate.lean",
        "theorems": [
          "TileStructure.Forest.nontangential_pointwise_bound"
        ]
      },
      {
        "file": "Carleson/Discrete/ForestComplement.lean",
        "theorems": [
          "carlesonSum_𝔓pos_inter_ℭ_eq_add_sum"
        ]
      },
      {
        "file": "Carleson/GridStructure.lean",
        "theorems": [
          "Grid.scale_succ"
        ]
      },
      {
        "file": "Carleson/ToMathlib/BoundedCompactSupport.lean",
        "theorems": [
          "MeasureTheory.BoundedCompactSupport.finset_sum"
        ]
      },
      {
        "file": "Carleson/Discrete/ForestUnion.lean",
        "theorems": [
          "forest_union_sum_aux1"
        ]
      },
      {
        "file": "Carleson/ForestOperator/Forests.lean",
        "theorems": [
          "forest_operator'"
        ]
      },
      {
        "file": "Carleson/ForestOperator/PointwiseEstimate.lean",
        "theorems": [
          "TileStructure.Forest.norm_approxOnCube_le_approxOnCube_norm"
        ]
      },
      {
        "file": "Carleson/ToMathlib/WeakType.lean",
        "theorems": [
          "MeasureTheory.distribution_add_le_of_enorm"
        ]
      },
      {
        "file": "Carleson/ToMathlib/Annulus.lean",
        "theorems": [
          "Set.EAnnulus.oo_subset_oi"
        ]
      },
      {
        "file": "Carleson/ToMathlib/WeakType.lean",
        "theorems": [
          "eLpNorm_toReal_le"
        ]
      },
      {
        "file": "Carleson/ForestOperator/L2Estimate.lean",
        "theorems": [
          "TileStructure.Forest.boundedCompactSupport_eI𝒬u_mul"
        ]
      }
    ],
    "ConNF": [
      {
        "file": "ConNF/Model/Result.lean",
        "theorems": [
          "ConNF.singletonImage'_spec"
        ]
      },
      {
        "file": "ConNF/External/Basic.lean",
        "theorems": [
          "ConNF.mem_powerset_iff"
        ]
      },
      {
        "file": "ConNF/Model/Hailperin.lean",
        "theorems": [
          "ConNF.TSet.exists_up"
        ]
      },
      {
        "file": "ConNF/External/Basic.lean",
        "theorems": [
          "ConNF.exists_smallUnion"
        ]
      },
      {
        "file": "ConNF/External/WellOrder.lean",
        "theorems": [
          "ConNF.supports_of_supports_singletons"
        ]
      },
      {
        "file": "ConNF/Levels/Path.lean",
        "theorems": [
          "ConNF.Path.coderiv_deriv'"
        ]
      },
      {
        "file": "ConNF/Model/TTT.lean",
        "theorems": [
          "ConNF.TSet.mem_smul_iff'"
        ]
      },
      {
        "file": "ConNF/Model/TTT.lean",
        "theorems": [
          "ConNF.TSet.exists_of_symmetric"
        ]
      },
      {
        "file": "ConNF/External/Basic.lean",
        "theorems": [
          "ConNF.mem_singletonUnion_iff"
        ]
      },
      {
        "file": "ConNF/Model/Hailperin.lean",
        "theorems": [
          "ConNF.TSet.exists_singletonImage"
        ]
      },
      {
        "file": "ConNF/External/Basic.lean",
        "theorems": [
          "ConNF.tSet_nonempty"
        ]
      },
      {
        "file": "ConNF/Model/TTT.lean",
        "theorems": [
          "ConNF.allPermEquiv_sderiv"
        ]
      },
      {
        "file": "ConNF/External/Basic.lean",
        "theorems": [
          "ConNF.externalRel_converse"
        ]
      },
      {
        "file": "ConNF/ModelData/Support.lean",
        "theorems": [
          "ConNF.Support.derivBot_atoms"
        ]
      },
      {
        "file": "ConNF/Model/RaiseStrong.lean",
        "theorems": [
          "ConNF.Support.sameSpecLe_of_fixes"
        ]
      },
      {
        "file": "ConNF/Model/TTT.lean",
        "theorems": [
          "ConNF.tSet_ext'"
        ]
      },
      {
        "file": "ConNF/Model/RaiseStrong.lean",
        "theorems": [
          "ConNF.Support.raise_preStrong'"
        ]
      },
      {
        "file": "ConNF/External/Basic.lean",
        "theorems": [
          "ConNF.mem_union_iff"
        ]
      },
      {
        "file": "ConNF/Model/Hailperin.lean",
        "theorems": [
          "ConNF.TSet.op_eq_singleton_iff"
        ]
      },
      {
        "file": "ConNF/Model/Hailperin.lean",
        "theorems": [
          "ConNF.TSet.exists_compl"
        ]
      },
      {
        "file": "ConNF/Model/Externalise.lean",
        "theorems": [
          "ConNF.globalLeData_eq"
        ]
      },
      {
        "file": "ConNF/ModelData/Support.lean",
        "theorems": [
          "ConNF.Support.scoderiv_deriv_eq"
        ]
      },
      {
        "file": "ConNF/Levels/Path.lean",
        "theorems": [
          "ConNF.Path.botDeriv_scoderiv"
        ]
      },
      {
        "file": "ConNF/Model/TTT.lean",
        "theorems": [
          "ConNF.sUnion_singleton_symmetric_aux"
        ]
      },
      {
        "file": "ConNF/ModelData/PathEnumeration.lean",
        "theorems": [
          "ConNF.Enumeration.eq_of_scoderiv_mem"
        ]
      },
      {
        "file": "ConNF/ModelData/Support.lean",
        "theorems": [
          "ConNF.Support.eq_of_nearLitter_mem_scoderiv_botDeriv"
        ]
      },
      {
        "file": "ConNF/Model/RaiseStrong.lean",
        "theorems": [
          "ConNF.Support.raise_closed'"
        ]
      },
      {
        "file": "ConNF/External/Basic.lean",
        "theorems": [
          "ConNF.mem_univ_iff"
        ]
      },
      {
        "file": "ConNF/Model/Hailperin.lean",
        "theorems": [
          "ConNF.TSet.exists_inter"
        ]
      },
      {
        "file": "ConNF/External/WellOrder.lean",
        "theorems": [
          "ConNF.powerset_internallyWellOrdered"
        ]
      },
      {
        "file": "ConNF/External/Basic.lean",
        "theorems": [
          "ConNF.mem_cross_iff"
        ]
      },
      {
        "file": "ConNF/Model/TTT.lean",
        "theorems": [
          "ConNF.allPermEquiv_forget"
        ]
      },
      {
        "file": "ConNF/ModelData/Support.lean",
        "theorems": [
          "ConNF.Support.sderiv_nearLitters"
        ]
      },
      {
        "file": "ConNF/Strong/Strong.lean",
        "theorems": [
          "ConNF.Support.PreStrong.add"
        ]
      },
      {
        "file": "ConNF/Model/Hailperin.lean",
        "theorems": [
          "ConNF.TSet.exists_cross"
        ]
      },
      {
        "file": "ConNF/Model/TTT.lean",
        "theorems": [
          "ConNF.allPerm_deriv_nil'"
        ]
      },
      {
        "file": "ConNF/External/Basic.lean",
        "theorems": [
          "ConNF.mem_orderedPairs_iff"
        ]
      },
      {
        "file": "ConNF/ModelData/Support.lean",
        "theorems": [
          "ConNF.Support.scoderiv_botDeriv_eq"
        ]
      },
      {
        "file": "ConNF/Model/RaiseStrong.lean",
        "theorems": [
          "ConNF.Support.litter_eq_of_flexible_of_fixes"
        ]
      },
      {
        "file": "ConNF/ModelData/Support.lean",
        "theorems": [
          "ConNF.Support.sderiv_atoms"
        ]
      },
      {
        "file": "ConNF/Model/Hailperin.lean",
        "theorems": [
          "ConNF.TSet.exists_typeLower"
        ]
      },
      {
        "file": "ConNF/Model/TTT.lean",
        "theorems": [
          "ConNF.allPerm_deriv_sderiv'"
        ]
      },
      {
        "file": "ConNF/Model/TTT.lean",
        "theorems": [
          "ConNF.typedMem_singleton_iff'"
        ]
      },
      {
        "file": "ConNF/Model/Result.lean",
        "theorems": [
          "ConNF.insertion3'_spec"
        ]
      },
      {
        "file": "ConNF/External/WellOrder.lean",
        "theorems": [
          "ConNF.internallyWellOrdered_of_common_support_of_nontrivial"
        ]
      },
      {
        "file": "ConNF/ModelData/Support.lean",
        "theorems": [
          "ConNF.Support.eq_of_atom_mem_scoderiv_botDeriv"
        ]
      },
      {
        "file": "ConNF/External/WellOrder.lean",
        "theorems": [
          "ConNF.apply_eq_of_isWellOrder"
        ]
      },
      {
        "file": "ConNF/Model/Externalise.lean",
        "theorems": [
          "ConNF.globalLtData_eq"
        ]
      },
      {
        "file": "ConNF/Model/Hailperin.lean",
        "theorems": [
          "ConNF.TSet.exists_subset"
        ]
      },
      {
        "file": "ConNF/External/WellOrder.lean",
        "theorems": [
          "ConNF.externalRel_smul"
        ]
      }
    ],
    "mathlib": [
      {
        "file": "Mathlib/NumberTheory/Padics/PadicIntegers.lean",
        "theorems": [
          "PadicInt.valuation_coe_nonneg"
        ]
      },
      {
        "file": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
        "theorems": [
          "Matrix.det_updateCol_eq_zero"
        ]
      },
      {
        "file": "Mathlib/Algebra/Module/ZLattice/Covolume.lean",
        "theorems": [
          "ZLattice.covolume.frontier_equivFun"
        ]
      },
      {
        "file": "Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean",
        "theorems": [
          "HomologicalComplex.extendHomologyIso_hom_naturality"
        ]
      },
      {
        "file": "Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean",
        "theorems": [
          "Complex.deriv_cpow_const"
        ]
      },
      {
        "file": "Mathlib/Analysis/Convex/StrictConvexSpace.lean",
        "theorems": [
          "StrictConvexSpace.of_strictConvex_unitClosedBall"
        ]
      },
      {
        "file": "Mathlib/Algebra/Order/Ring/Canonical.lean",
        "theorems": [
          "CanonicallyOrderedAdd.pow_pos"
        ]
      },
      {
        "file": "Mathlib/NumberTheory/Padics/PadicIntegers.lean",
        "theorems": [
          "PadicInt.valuation_mul"
        ]
      },
      {
        "file": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
        "theorems": [
          "Matrix.det_eq_detp_sub_detp"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Polynomial/HilbertPoly.lean",
        "theorems": [
          "Polynomial.natDegree_hilbertPoly_of_ne_zero"
        ]
      },
      {
        "file": "Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean",
        "theorems": [
          "HomologicalComplex.pOpcycles_extendOpcyclesIso_inv"
        ]
      },
      {
        "file": "Mathlib/Data/List/ReduceOption.lean",
        "theorems": [
          "List.reduceOption_eq_singleton_iff"
        ]
      },
      {
        "file": "Mathlib/Geometry/Manifold/Algebra/SmoothFunctions.lean",
        "theorems": [
          "ContMDiffMap.coe_one"
        ]
      },
      {
        "file": "Mathlib/Data/Set/Pairwise/Lattice.lean",
        "theorems": [
          "Set.pairwiseDisjoint_iff"
        ]
      },
      {
        "file": "Mathlib/Algebra/Order/Ring/Canonical.lean",
        "theorems": [
          "CanonicallyOrderedAdd.mul_pos"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Polynomial/HilbertPoly.lean",
        "theorems": [
          "Polynomial.hilbertPoly_succ"
        ]
      },
      {
        "file": "Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean",
        "theorems": [
          "HomologicalComplex.extendHomologyIso_inv_homologyι"
        ]
      },
      {
        "file": "Mathlib/Order/Atoms.lean",
        "theorems": [
          "SetLike.isCoatom_iff"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Polynomial/HilbertPoly.lean",
        "theorems": [
          "Polynomial.hilbertPoly_eq_zero_of_le_rootMultiplicity_one"
        ]
      },
      {
        "file": "Mathlib/Data/Set/Pairwise/Lattice.lean",
        "theorems": [
          "Set.pairwiseDisjoint_pair_insert"
        ]
      },
      {
        "file": "Mathlib/Algebra/Module/CharacterModule.lean",
        "theorems": [
          "CharacterModule.dual_injective_iff_surjective"
        ]
      },
      {
        "file": "Mathlib/Algebra/Module/ZLattice/Covolume.lean",
        "theorems": [
          "ZLattice.covolume.tendsto_card_le_div"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Valuation/Basic.lean",
        "theorems": [
          "AddValuation.ofValuation_symm_eq"
        ]
      },
      {
        "file": "Mathlib/NumberTheory/Padics/PadicIntegers.lean",
        "theorems": [
          "PadicInt.norm_eq_zpow_neg_valuation"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Polynomial/HilbertPoly.lean",
        "theorems": [
          "Polynomial.existsUnique_hilbertPoly"
        ]
      },
      {
        "file": "Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean",
        "theorems": [
          "HomologicalComplex.quasiIso_extendMap_iff"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Valuation/Basic.lean",
        "theorems": [
          "Valuation.ofAddValuation_apply"
        ]
      },
      {
        "file": "Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean",
        "theorems": [
          "isTheta_deriv_ofReal_cpow_const_atTop"
        ]
      },
      {
        "file": "Mathlib/Algebra/Homology/Embedding/Boundary.lean",
        "theorems": [
          "ComplexShape.Embedding.op_boundaryLE_iff"
        ]
      },
      {
        "file": "Mathlib/Order/Atoms.lean",
        "theorems": [
          "SetLike.covBy_iff"
        ]
      },
      {
        "file": "Mathlib/RingTheory/PowerSeries/WellKnown.lean",
        "theorems": [
          "PowerSeries.invOneSubPow_inv_zero_eq_one"
        ]
      },
      {
        "file": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
        "theorems": [
          "Matrix.det_updateCol_sum"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Etale/Field.lean",
        "theorems": [
          "Algebra.Etale.iff_exists_algEquiv_prod"
        ]
      },
      {
        "file": "Mathlib/Algebra/Module/ZLattice/Covolume.lean",
        "theorems": [
          "ZLattice.covolume.tendsto_card_le_div''"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Valuation/Basic.lean",
        "theorems": [
          "Valuation.ofAddValuation_toAddValuation"
        ]
      },
      {
        "file": "Mathlib/RingTheory/PowerSeries/WellKnown.lean",
        "theorems": [
          "PowerSeries.one_sub_pow_add_mul_invOneSubPow_val_eq_one_sub_pow"
        ]
      },
      {
        "file": "Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean",
        "theorems": [
          "HomologicalComplex.homologyπ_extendHomologyIso_inv"
        ]
      },
      {
        "file": "Mathlib/Combinatorics/Additive/ApproximateSubgroup.lean",
        "theorems": [
          "IsApproximateSubgroup.pow_inter_pow_covBySMul_sq_inter_sq"
        ]
      },
      {
        "file": "Mathlib/NumberTheory/Padics/PadicIntegers.lean",
        "theorems": [
          "PadicInt.valuation_pow"
        ]
      },
      {
        "file": "Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean",
        "theorems": [
          "hasDerivAt_ofReal_cpow_const'"
        ]
      },
      {
        "file": "Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean",
        "theorems": [
          "HomologicalComplex.extend_exactAt"
        ]
      },
      {
        "file": "Mathlib/RingTheory/PowerSeries/WellKnown.lean",
        "theorems": [
          "PowerSeries.invOneSubPow_add"
        ]
      },
      {
        "file": "Mathlib/Algebra/Homology/Embedding/Boundary.lean",
        "theorems": [
          "ComplexShape.Embedding.op_boundaryGE_iff"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Valuation/Basic.lean",
        "theorems": [
          "AddValuation.ofValuation_toValuation"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Polynomial/HilbertPoly.lean",
        "theorems": [
          "Polynomial.hilbertPoly_zero_right"
        ]
      },
      {
        "file": "Mathlib/Combinatorics/Additive/ApproximateSubgroup.lean",
        "theorems": [
          "IsApproximateSubgroup.card_mul_self_le"
        ]
      },
      {
        "file": "Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean",
        "theorems": [
          "hasDerivAt_ofReal_cpow_const"
        ]
      },
      {
        "file": "Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean",
        "theorems": [
          "HomologicalComplex.extend_exactAt_iff"
        ]
      },
      {
        "file": "Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean",
        "theorems": [
          "deriv_norm_ofReal_cpow"
        ]
      },
      {
        "file": "Mathlib/RingTheory/Polynomial/HilbertPoly.lean",
        "theorems": [
          "Polynomial.eq_hilbertPoly_of_forall_coeff_eq_eval"
        ]
      }
    ]
  }
}